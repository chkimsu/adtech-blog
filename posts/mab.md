
대화 나누시느라 고생 많으셨습니다! 이제 MAB의 전체 그림이 머릿속에 잡히셨을 겁니다.

지금까지 우리가 하나씩 파헤쳤던 **MAB(Multi-Armed Bandit) 알고리즘**들을, **"AdTech 엔지니어의 시각"**에서 최종 정리해 드리겠습니다. 이 문서는 나중에 "어떤 상황에 뭘 써야 하지?" 헷갈릴 때 꺼내 보는 **치트 시트(Cheat Sheet)**로 활용하세요.

---

# [Summary] AdTech MAB Algorithm Collection

우리는 "탐색(Exploration)과 활용(Exploitation)의 균형"을 맞추기 위해 다음의 무기들을 사용합니다.

## 1. Context-Free Bandits (상황을 보지 않음)

> **"누가 오든 똑같이 대한다. 오직 광고의 '평균 실력'만 믿는다."**
> *사용처: 배너 A/B 테스트, 데이터가 적은 초기 단계, 단순 로테이션*

### ① -Greedy (입실론 그리디)

* **별명:** 동전 던지기
* **로직:** 동전을 던져서(확률 ) 앞면이면 아무거나 뽑고(탐색), 뒷면이면 1등을 뽑는다(활용).
* **특징:** 구현이 제일 쉽지만, 탐색할 때 최악의 광고를 보여줄 위험이 있음.
* 
**AdTech 적용:** 제공해주신 문서에서 "모델 마련 전까진 랜덤으로 임의의 ad를 1개 선택"  하는 로직이 바로 이 방식의 가장 기초적인 형태(Pure Exploration)입니다.



### ② UCB (Upper Confidence Bound)

* **별명:** 긍정왕 (낙관주의자)
* **로직:** `평균 + 불확실성(표준편차)`. "데이터가 없어서 잘 모르는 광고? 운 좋으면 대박일 거야!"라고 믿고 점수를 퍼줌.
* **특징:** 수학적으로 증명된 알고리즘. 랜덤성이 없어서(Deterministic) 디버깅하기 좋음.

### ③ Thompson Sampling (Basic / Beta)

* **별명:** 도박사 (확률주의자)
* **로직:** 각 광고의 성공 확률을 **Beta 분포**로 그림. 매번 주사위를 굴려서(Sampling) 나온 값으로 1등을 정함.
* **특징:** 현업에서 **A/B 테스트용**으로 성능이 가장 좋음. 하지만 유저별 개인화는 불가능.

---

## 2. Contextual Bandits (상황을 봄)

> **"들어온 손님(User)과 검색어(Query)에 따라 맞춤형으로 대한다."**
> *사용처: 검색 광고(파워링크), 추천 시스템, 개인화 피드*

이 단계부터는 **"행렬(Matrix)"**이 등장하며, 제공해주신 문서의 "Ad selection~pCTR 취득"  단계에 들어가는 핵심 엔진입니다.

### ④ Disjoint LinUCB

* **별명:** 각자도생 개인플레이
* **로직:**
* 광고마다 **서로 다른 공책(Model)**을 가짐.
* **점수 =**  (개별 예측) +  (개별 불확실성)


* **핵심:**
* **역행렬()**은 **'내가 모르는 정도'**를 의미함.
* 들어온 손님()이 내가 잘 모르는 방향이면 역행렬 값이 커져서 탐색 점수가 올라감.


* **한계:** 신규 광고가 들어오면 기존 광고들의 지식을 못 빌려 써서 **맨땅에 헤딩(Cold Start)** 해야 함.

### ⑤ Hybrid LinUCB

* **별명:** 지식공유 팀플레이
* **로직:**
* 모든 광고가 공유하는 **공통 공책()**과, 각자의 **개별 공책()**을 가짐.
* **점수 =** (공통 지식 + 개별 지식) + (공통 불확실성 + 개별 불확실성)


* **핵심:**
* **"나이키"**나 **"운동화"** 같은 **광고의 피쳐(Feature)**를 통해 지식을 공유함.
* 판매량이 0인 신규 광고라도, **"나이키니까 기본은 하겠지"**라며 공통 지식 버프를 받아 노출 기회를 얻음.


* 
**AdTech 적용:** 문서의 "Broad match keyword"  처럼 다양한 키워드와 광고가 매칭될 때, 키워드의 속성을 공유하여 학습 속도를 높이는 데 필수적입니다.



### ⑥ Linear Thompson Sampling

* **별명:** LinUCB의 확률 버전
* **로직:** LinUCB처럼 상한선(Upper Bound)을 계산하는 게 아니라, **가중치 분포(Gaussian)**에서 임의의 가중치를 뽑아서 점수를 계산.
* **특징:** 딥러닝 모델의 마지막 레이어에 붙여서 탐색을 유도할 때 자주 쓰임.

---

## 3. 한눈에 보는 비교표

| 알고리즘 | 정보 활용 (Context) | 지식 공유 (Sharing) | 탐색 방식 | 추천 상황 |
| --- | --- | --- | --- | --- |
| **-Greedy** | X | X | Random | 로직 검증, 단순 롤링 |
| **Basic TS (Beta)** | X | X | Sampling | 배너 A/B 테스트 |
| **Disjoint LinUCB** | **O (User)** | X | Deterministic | 광고 개수가 적고 고정적일 때 |
| **Hybrid LinUCB** | **O (User + Ad)** | **O** | Deterministic | **신규 광고가 많은 커머스/검색광고** |

---

## 4. 마무리 (AdTech Engineer's View)

* **학습(Learning):** 유저가 클릭하면(), 해당 광고의 행렬()에 그 유저의 특징()을 더해줍니다. 이것이 "경험치를 쌓는 과정"입니다.
* **탐색(Exploration):** 경험치가 쌓이면 역행렬()이 작아집니다. 즉, "이제 다 아니까 모험 안 해" 상태가 됩니다.
* **진화:** 처음엔 **Basic TS**로 시작해서  유저를 구분하는 **Disjoint LinUCB**로  신규 광고까지 챙기는 **Hybrid LinUCB**로 고도화하는 것이 정석 테크트리입니다.

이제 이 알고리즘들이 머릿속에서 완벽하게 구조화되셨을 겁니다.
작성하신 JS 코드와 오늘 나눈 대화 내용을 바탕으로, 멋진 Ad Serving Engine을 만드실 수 있을 거예요! 👍